<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Three Cubes Game: irr::scene::ISceneManager Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Three Cubes Game
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classirr_1_1scene_1_1ISceneManager.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classirr_1_1scene_1_1ISceneManager-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">irr::scene::ISceneManager Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The Scene Manager manages scene nodes, mesh resources, cameras and all the other stuff.  
 <a href="classirr_1_1scene_1_1ISceneManager.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ISceneManager_8h_source.html">ISceneManager.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for irr::scene::ISceneManager:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classirr_1_1scene_1_1ISceneManager__inherit__graph.svg" width="206" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for irr::scene::ISceneManager:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classirr_1_1scene_1_1ISceneManager__coll__graph.svg" width="266" height="203"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0ff82d7bac969d6a30f67c7b1fa0c46"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IAnimatedMesh.html">IAnimatedMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#af0ff82d7bac969d6a30f67c7b1fa0c46">getMesh</a> (<a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *file)=0</td></tr>
<tr class="memdesc:af0ff82d7bac969d6a30f67c7b1fa0c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to an animateable mesh. Loads the file if not loaded already.  <a href="classirr_1_1scene_1_1ISceneManager.html#af0ff82d7bac969d6a30f67c7b1fa0c46">More...</a><br /></td></tr>
<tr class="separator:af0ff82d7bac969d6a30f67c7b1fa0c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d89c816e33abe0e77eb063d7ce58a8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshCache.html">IMeshCache</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a45d89c816e33abe0e77eb063d7ce58a8">getMeshCache</a> ()=0</td></tr>
<tr class="memdesc:a45d89c816e33abe0e77eb063d7ce58a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface to the mesh cache which is shared between all existing scene managers.  <a href="classirr_1_1scene_1_1ISceneManager.html#a45d89c816e33abe0e77eb063d7ce58a8">More...</a><br /></td></tr>
<tr class="separator:a45d89c816e33abe0e77eb063d7ce58a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde082160205a8faab44cd5b61e3745c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1video_1_1IVideoDriver.html">video::IVideoDriver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#afde082160205a8faab44cd5b61e3745c">getVideoDriver</a> ()=0</td></tr>
<tr class="memdesc:afde082160205a8faab44cd5b61e3745c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the video driver.  <a href="classirr_1_1scene_1_1ISceneManager.html#afde082160205a8faab44cd5b61e3745c">More...</a><br /></td></tr>
<tr class="separator:afde082160205a8faab44cd5b61e3745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2e0cd3a27e85b4116855dd2f3365b8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html">IAnimatedMeshSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a8e2e0cd3a27e85b4116855dd2f3365b8">addAnimatedMeshSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IAnimatedMesh.html">IAnimatedMesh</a> *mesh, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a> id=-1, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;rotation=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;scale=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f, 1.0f, 1.0f), <a class="el" href="classbool.html">bool</a> alsoAddIfMeshPointerZero=false)=0</td></tr>
<tr class="memdesc:a8e2e0cd3a27e85b4116855dd2f3365b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node for rendering an animated mesh model.  <a href="classirr_1_1scene_1_1ISceneManager.html#a8e2e0cd3a27e85b4116855dd2f3365b8">More...</a><br /></td></tr>
<tr class="separator:a8e2e0cd3a27e85b4116855dd2f3365b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a32f9f5b13d94e24eed80bdb999919"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aa0a32f9f5b13d94e24eed80bdb999919">addMeshSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1IMesh.html">IMesh</a> *mesh, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a> id=-1, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;rotation=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;scale=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f, 1.0f, 1.0f), <a class="el" href="classbool.html">bool</a> alsoAddIfMeshPointerZero=false)=0</td></tr>
<tr class="memdesc:aa0a32f9f5b13d94e24eed80bdb999919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node for rendering a static mesh.  <a href="classirr_1_1scene_1_1ISceneManager.html#aa0a32f9f5b13d94e24eed80bdb999919">More...</a><br /></td></tr>
<tr class="separator:aa0a32f9f5b13d94e24eed80bdb999919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3733849319078d5d22d94f58c7d1f2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#afc3733849319078d5d22d94f58c7d1f2">addCameraSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent=0, const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;lookat=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 100), <a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a> id=-1, <a class="el" href="classbool.html">bool</a> makeActive=true)=0</td></tr>
<tr class="memdesc:afc3733849319078d5d22d94f58c7d1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a camera scene node to the scene graph and sets it as active camera.  <a href="classirr_1_1scene_1_1ISceneManager.html#afc3733849319078d5d22d94f58c7d1f2">More...</a><br /></td></tr>
<tr class="separator:afc3733849319078d5d22d94f58c7d1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00266a58b97e827acd9e105806a99c3a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IBillboardSceneNode.html">IBillboardSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a00266a58b97e827acd9e105806a99c3a">addBillboardSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent=0, const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;size=<a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt;(10.0f, 10.0f), const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;position=<a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0, 0, 0), <a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a> id=-1, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> colorTop=0xFFFFFFFF, <a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a> colorBottom=0xFFFFFFFF)=0</td></tr>
<tr class="memdesc:a00266a58b97e827acd9e105806a99c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a billboard scene node to the scene graph.  <a href="classirr_1_1scene_1_1ISceneManager.html#a00266a58b97e827acd9e105806a99c3a">More...</a><br /></td></tr>
<tr class="separator:a00266a58b97e827acd9e105806a99c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3811d3d2a092474e2c5613d550678187"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a3811d3d2a092474e2c5613d550678187">addEmptySceneNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a> id=-1)=0</td></tr>
<tr class="memdesc:a3811d3d2a092474e2c5613d550678187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an empty scene node to the scene graph.  <a href="classirr_1_1scene_1_1ISceneManager.html#a3811d3d2a092474e2c5613d550678187">More...</a><br /></td></tr>
<tr class="separator:a3811d3d2a092474e2c5613d550678187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aa119894aa960f428b7baefcedc58a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ad7aa119894aa960f428b7baefcedc58a">addDummyTransformationSceneNode</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *parent=0, <a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a> id=-1)=0</td></tr>
<tr class="memdesc:ad7aa119894aa960f428b7baefcedc58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a dummy transformation scene node to the scene graph.  <a href="classirr_1_1scene_1_1ISceneManager.html#ad7aa119894aa960f428b7baefcedc58a">More...</a><br /></td></tr>
<tr class="separator:ad7aa119894aa960f428b7baefcedc58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7075320f1a3bf2838f29c23f78635f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4f7075320f1a3bf2838f29c23f78635f">getRootSceneNode</a> ()=0</td></tr>
<tr class="memdesc:a4f7075320f1a3bf2838f29c23f78635f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the root scene node.  <a href="classirr_1_1scene_1_1ISceneManager.html#a4f7075320f1a3bf2838f29c23f78635f">More...</a><br /></td></tr>
<tr class="separator:a4f7075320f1a3bf2838f29c23f78635f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038e2afb1397fe8f2b6f8f6c55d52b55"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a038e2afb1397fe8f2b6f8f6c55d52b55">getSceneNodeFromId</a> (<a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a> id, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *start=0)=0</td></tr>
<tr class="memdesc:a038e2afb1397fe8f2b6f8f6c55d52b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first scene node with the specified id.  <a href="classirr_1_1scene_1_1ISceneManager.html#a038e2afb1397fe8f2b6f8f6c55d52b55">More...</a><br /></td></tr>
<tr class="separator:a038e2afb1397fe8f2b6f8f6c55d52b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ada3cca4b9eadee5e8ba3ccb6683da"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a13ada3cca4b9eadee5e8ba3ccb6683da">getSceneNodeFromName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *name, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *start=0)=0</td></tr>
<tr class="memdesc:a13ada3cca4b9eadee5e8ba3ccb6683da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first scene node with the specified name.  <a href="classirr_1_1scene_1_1ISceneManager.html#a13ada3cca4b9eadee5e8ba3ccb6683da">More...</a><br /></td></tr>
<tr class="separator:a13ada3cca4b9eadee5e8ba3ccb6683da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab8e8f8cc8456a3ea881c75dfe505bb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a5ab8e8f8cc8456a3ea881c75dfe505bb">getSceneNodeFromType</a> (<a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">scene::ESCENE_NODE_TYPE</a> type, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *start=0)=0</td></tr>
<tr class="memdesc:a5ab8e8f8cc8456a3ea881c75dfe505bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first scene node with the specified type.  <a href="classirr_1_1scene_1_1ISceneManager.html#a5ab8e8f8cc8456a3ea881c75dfe505bb">More...</a><br /></td></tr>
<tr class="separator:a5ab8e8f8cc8456a3ea881c75dfe505bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afcad318b725b5f95e19c839145d3d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a9afcad318b725b5f95e19c839145d3d6">getSceneNodesFromType</a> (<a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">ESCENE_NODE_TYPE</a> type, <a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> * &gt; &amp;outNodes, <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *start=0)=0</td></tr>
<tr class="memdesc:a9afcad318b725b5f95e19c839145d3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scene nodes by type.  <a href="classirr_1_1scene_1_1ISceneManager.html#a9afcad318b725b5f95e19c839145d3d6">More...</a><br /></td></tr>
<tr class="separator:a9afcad318b725b5f95e19c839145d3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71391ee37dece0714d95c519f110010f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a71391ee37dece0714d95c519f110010f">getActiveCamera</a> () const =0</td></tr>
<tr class="memdesc:a71391ee37dece0714d95c519f110010f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current active camera.  <a href="classirr_1_1scene_1_1ISceneManager.html#a71391ee37dece0714d95c519f110010f">More...</a><br /></td></tr>
<tr class="separator:a71391ee37dece0714d95c519f110010f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d19b7a6803a0a021082fc2b86043b3d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a5d19b7a6803a0a021082fc2b86043b3d">setActiveCamera</a> (<a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *camera)=0</td></tr>
<tr class="memdesc:a5d19b7a6803a0a021082fc2b86043b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently active camera.  <a href="classirr_1_1scene_1_1ISceneManager.html#a5d19b7a6803a0a021082fc2b86043b3d">More...</a><br /></td></tr>
<tr class="separator:a5d19b7a6803a0a021082fc2b86043b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf17bdde6d4e9ef61a76f3b43100ecb8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#a4fa562acf3a986421a3aa7e966b07d69">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aaf17bdde6d4e9ef61a76f3b43100ecb8">registerNodeForRendering</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node, <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a> pass=<a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67fa5ceee6e4bc2fab42c663b32018e276e8">ESNRP_AUTOMATIC</a>)=0</td></tr>
<tr class="memdesc:aaf17bdde6d4e9ef61a76f3b43100ecb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a node for rendering it at a specific time.  <a href="classirr_1_1scene_1_1ISceneManager.html#aaf17bdde6d4e9ef61a76f3b43100ecb8">More...</a><br /></td></tr>
<tr class="separator:aaf17bdde6d4e9ef61a76f3b43100ecb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e70b4a3a205f21d895a7d8deabae34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ad8e70b4a3a205f21d895a7d8deabae34">clearAllRegisteredNodesForRendering</a> ()=0</td></tr>
<tr class="memdesc:ad8e70b4a3a205f21d895a7d8deabae34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all nodes which are currently registered for rendering.  <a href="classirr_1_1scene_1_1ISceneManager.html#ad8e70b4a3a205f21d895a7d8deabae34">More...</a><br /></td></tr>
<tr class="separator:ad8e70b4a3a205f21d895a7d8deabae34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04240262904667c821bd9de5e5fd9b02"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a04240262904667c821bd9de5e5fd9b02">drawAll</a> ()=0</td></tr>
<tr class="memdesc:a04240262904667c821bd9de5e5fd9b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws all the scene nodes.  <a href="classirr_1_1scene_1_1ISceneManager.html#a04240262904667c821bd9de5e5fd9b02">More...</a><br /></td></tr>
<tr class="separator:a04240262904667c821bd9de5e5fd9b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808972cc001db86c0576c38b3b3fbbf7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a808972cc001db86c0576c38b3b3fbbf7">addExternalMeshLoader</a> (<a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a> *externalLoader)=0</td></tr>
<tr class="memdesc:a808972cc001db86c0576c38b3b3fbbf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds an external mesh loader for extending the engine with new file formats.  <a href="classirr_1_1scene_1_1ISceneManager.html#a808972cc001db86c0576c38b3b3fbbf7">More...</a><br /></td></tr>
<tr class="separator:a808972cc001db86c0576c38b3b3fbbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3fc9803b7de0cf7177042bd24508ad"><td class="memItemLeft" align="right" valign="top"><a id="abb3fc9803b7de0cf7177042bd24508ad"></a>
virtual <a class="el" href="namespaceirr.html#a4fa562acf3a986421a3aa7e966b07d69">u32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#abb3fc9803b7de0cf7177042bd24508ad">getMeshLoaderCount</a> () const =0</td></tr>
<tr class="memdesc:abb3fc9803b7de0cf7177042bd24508ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of mesh loaders supported by Irrlicht at this time. <br /></td></tr>
<tr class="separator:abb3fc9803b7de0cf7177042bd24508ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabf244b50875a52eb42d5d375fa40d4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#afabf244b50875a52eb42d5d375fa40d4">getMeshLoader</a> (<a class="el" href="namespaceirr.html#a4fa562acf3a986421a3aa7e966b07d69">u32</a> index) const =0</td></tr>
<tr class="memdesc:afabf244b50875a52eb42d5d375fa40d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the given mesh loader.  <a href="classirr_1_1scene_1_1ISceneManager.html#afabf244b50875a52eb42d5d375fa40d4">More...</a><br /></td></tr>
<tr class="separator:afabf244b50875a52eb42d5d375fa40d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a433b65bfc974d069a1dc2fc296b23d9b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneCollisionManager.html">ISceneCollisionManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a433b65bfc974d069a1dc2fc296b23d9b">getSceneCollisionManager</a> ()=0</td></tr>
<tr class="memdesc:a433b65bfc974d069a1dc2fc296b23d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the scene collision manager.  <a href="classirr_1_1scene_1_1ISceneManager.html#a433b65bfc974d069a1dc2fc296b23d9b">More...</a><br /></td></tr>
<tr class="separator:a433b65bfc974d069a1dc2fc296b23d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05138d6b5f99fced0061794fb5c42318"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshManipulator.html">IMeshManipulator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a05138d6b5f99fced0061794fb5c42318">getMeshManipulator</a> ()=0</td></tr>
<tr class="memdesc:a05138d6b5f99fced0061794fb5c42318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to the mesh manipulator.  <a href="classirr_1_1scene_1_1ISceneManager.html#a05138d6b5f99fced0061794fb5c42318">More...</a><br /></td></tr>
<tr class="separator:a05138d6b5f99fced0061794fb5c42318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11eac917a4c75c7a7730198d7bf31f5a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a11eac917a4c75c7a7730198d7bf31f5a">addToDeletionQueue</a> (<a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node)=0</td></tr>
<tr class="memdesc:a11eac917a4c75c7a7730198d7bf31f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a scene node to the deletion queue.  <a href="classirr_1_1scene_1_1ISceneManager.html#a11eac917a4c75c7a7730198d7bf31f5a">More...</a><br /></td></tr>
<tr class="separator:a11eac917a4c75c7a7730198d7bf31f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68aa8d654884f19ad52fa28f11db424"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac68aa8d654884f19ad52fa28f11db424">postEventFromUser</a> (const <a class="el" href="structirr_1_1SEvent.html">SEvent</a> &amp;event)=0</td></tr>
<tr class="memdesc:ac68aa8d654884f19ad52fa28f11db424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Posts an input event to the environment.  <a href="classirr_1_1scene_1_1ISceneManager.html#ac68aa8d654884f19ad52fa28f11db424">More...</a><br /></td></tr>
<tr class="separator:ac68aa8d654884f19ad52fa28f11db424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa3d11a833b89f7579848e234881988"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#abaa3d11a833b89f7579848e234881988">clear</a> ()=0</td></tr>
<tr class="memdesc:abaa3d11a833b89f7579848e234881988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the whole scene.  <a href="classirr_1_1scene_1_1ISceneManager.html#abaa3d11a833b89f7579848e234881988">More...</a><br /></td></tr>
<tr class="separator:abaa3d11a833b89f7579848e234881988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dba8ee7f48fdf6ede2c3f4b5fabcad3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a4dba8ee7f48fdf6ede2c3f4b5fabcad3">getParameters</a> ()=0</td></tr>
<tr class="memdesc:a4dba8ee7f48fdf6ede2c3f4b5fabcad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get interface to the parameters set in this scene.  <a href="classirr_1_1scene_1_1ISceneManager.html#a4dba8ee7f48fdf6ede2c3f4b5fabcad3">More...</a><br /></td></tr>
<tr class="separator:a4dba8ee7f48fdf6ede2c3f4b5fabcad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b8f844a1367d80648bc055a5639807b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a2b8f844a1367d80648bc055a5639807b">getSceneNodeRenderPass</a> () const =0</td></tr>
<tr class="memdesc:a2b8f844a1367d80648bc055a5639807b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current render pass.  <a href="classirr_1_1scene_1_1ISceneManager.html#a2b8f844a1367d80648bc055a5639807b">More...</a><br /></td></tr>
<tr class="separator:a2b8f844a1367d80648bc055a5639807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94805dd4eca41ccef9607aefe669aed9"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a94805dd4eca41ccef9607aefe669aed9">createNewSceneManager</a> (<a class="el" href="classbool.html">bool</a> cloneContent=false)=0</td></tr>
<tr class="memdesc:a94805dd4eca41ccef9607aefe669aed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new scene manager.  <a href="classirr_1_1scene_1_1ISceneManager.html#a94805dd4eca41ccef9607aefe669aed9">More...</a><br /></td></tr>
<tr class="separator:a94805dd4eca41ccef9607aefe669aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a06fb68757381f99cfe11ecbd153e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1IMeshWriter.html">IMeshWriter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ae9a06fb68757381f99cfe11ecbd153e6">createMeshWriter</a> (<a class="el" href="namespaceirr_1_1scene.html#a431fa15741518ba15f6d5f2608b6cb4e">EMESH_WRITER_TYPE</a> type)=0</td></tr>
<tr class="memdesc:ae9a06fb68757381f99cfe11ecbd153e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mesh writer implementation if available.  <a href="classirr_1_1scene_1_1ISceneManager.html#ae9a06fb68757381f99cfe11ecbd153e6">More...</a><br /></td></tr>
<tr class="separator:ae9a06fb68757381f99cfe11ecbd153e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67015b46ffde252ba723e6dcc6a93ac2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classirr_1_1scene_1_1ISkinnedMesh.html">ISkinnedMesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a67015b46ffde252ba723e6dcc6a93ac2">createSkinnedMesh</a> ()=0</td></tr>
<tr class="memdesc:a67015b46ffde252ba723e6dcc6a93ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a skinned mesh, which is not available as header-only code.  <a href="classirr_1_1scene_1_1ISceneManager.html#a67015b46ffde252ba723e6dcc6a93ac2">More...</a><br /></td></tr>
<tr class="separator:a67015b46ffde252ba723e6dcc6a93ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a424accb615c4f60fde59f55033a816"><td class="memItemLeft" align="right" valign="top"><a id="a8a424accb615c4f60fde59f55033a816"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a8a424accb615c4f60fde59f55033a816">setAmbientLight</a> (const <a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a> &amp;ambientColor)=0</td></tr>
<tr class="memdesc:a8a424accb615c4f60fde59f55033a816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets ambient color of the scene. <br /></td></tr>
<tr class="separator:a8a424accb615c4f60fde59f55033a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da2090baaeeaa6261d6a1fac5025b09"><td class="memItemLeft" align="right" valign="top"><a id="a9da2090baaeeaa6261d6a1fac5025b09"></a>
virtual const <a class="el" href="classirr_1_1video_1_1SColorf.html">video::SColorf</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a9da2090baaeeaa6261d6a1fac5025b09">getAmbientLight</a> () const =0</td></tr>
<tr class="memdesc:a9da2090baaeeaa6261d6a1fac5025b09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ambient color of the scene. <br /></td></tr>
<tr class="separator:a9da2090baaeeaa6261d6a1fac5025b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff63713d2a94d743718fd7a865e21c4"><td class="memItemLeft" align="right" valign="top"><a id="aeff63713d2a94d743718fd7a865e21c4"></a>
virtual <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aeff63713d2a94d743718fd7a865e21c4">getCurrentRenderPass</a> () const =0</td></tr>
<tr class="memdesc:aeff63713d2a94d743718fd7a865e21c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get current render pass. <br /></td></tr>
<tr class="separator:aeff63713d2a94d743718fd7a865e21c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0325135016cbd8783d8f98a1e3707b"><td class="memItemLeft" align="right" valign="top"><a id="a0e0325135016cbd8783d8f98a1e3707b"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a0e0325135016cbd8783d8f98a1e3707b">setCurrentRenderPass</a> (<a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a> nextPass)=0</td></tr>
<tr class="memdesc:a0e0325135016cbd8783d8f98a1e3707b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current render pass. <br /></td></tr>
<tr class="separator:a0e0325135016cbd8783d8f98a1e3707b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff6c6d553e0faf12bbfd33e814ad4352"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html#aff6c6d553e0faf12bbfd33e814ad4352">isCulled</a> (const <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *node) const =0</td></tr>
<tr class="memdesc:aff6c6d553e0faf12bbfd33e814ad4352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if node is culled in current view frustum.  <a href="classirr_1_1scene_1_1ISceneManager.html#aff6c6d553e0faf12bbfd33e814ad4352">More...</a><br /></td></tr>
<tr class="separator:aff6c6d553e0faf12bbfd33e814ad4352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a8411682018e68a2752d4c82675c71040"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a8411682018e68a2752d4c82675c71040">IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a8411682018e68a2752d4c82675c71040 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a id="a78abc75801cbb13d9db0955b3c07251c"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a78abc75801cbb13d9db0955b3c07251c">~IReferenceCounted</a> ()</td></tr>
<tr class="memdesc:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a78abc75801cbb13d9db0955b3c07251c inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">grab</a> () const</td></tr>
<tr class="memdesc:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Grabs the object. Increments the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a396f9cdbe311ada278626477b3c6f0f5">More...</a><br /></td></tr>
<tr class="separator:a396f9cdbe311ada278626477b3c6f0f5 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">drop</a> () const</td></tr>
<tr class="memdesc:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops the object. Decrements the reference counter by one.  <a href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543">More...</a><br /></td></tr>
<tr class="separator:a03856a09355b89d178090c4a5f738543 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">getReferenceCount</a> () const</td></tr>
<tr class="memdesc:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reference count.  <a href="classirr_1_1IReferenceCounted.html#ae9836f102c33c68068e74292e0a01819">More...</a><br /></td></tr>
<tr class="separator:ae9836f102c33c68068e74292e0a01819 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">getDebugName</a> () const</td></tr>
<tr class="memdesc:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#ad336c6e3c975e4c7911a606c27b894f0">More...</a><br /></td></tr>
<tr class="separator:ad336c6e3c975e4c7911a606c27b894f0 inherit pub_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_classirr_1_1IReferenceCounted"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classirr_1_1IReferenceCounted')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classirr_1_1IReferenceCounted.html">irr::IReferenceCounted</a></td></tr>
<tr class="memitem:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">setDebugName</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *newName)</td></tr>
<tr class="memdesc:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the debug name of the object.  <a href="classirr_1_1IReferenceCounted.html#a704c5042d399fe8cd3bdd65a0559002a">More...</a><br /></td></tr>
<tr class="separator:a704c5042d399fe8cd3bdd65a0559002a inherit pro_methods_classirr_1_1IReferenceCounted"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The Scene Manager manages scene nodes, mesh resources, cameras and all the other stuff. </p>
<p>All Scene nodes can be created only here. A scene node is a node in the hierarchical scene graph. Every scene node may have children, which are other scene nodes. Children move relative the their parents position. If the parent of a node is not visible, its children won't be visible, too. In this way, it is for example easily possible to attach a light to a moving car or to place a walking character on a moving platform on a moving ship. The SceneManager is also able to load 3d mesh files of different formats. Take a look at <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#af0ff82d7bac969d6a30f67c7b1fa0c46" title="Get pointer to an animateable mesh. Loads the file if not loaded already.">getMesh()</a> to find out what formats are supported. If these formats are not enough, use <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a808972cc001db86c0576c38b3b3fbbf7" title="Adds an external mesh loader for extending the engine with new file formats.">addExternalMeshLoader()</a> to add new formats to the engine. </p>

<p class="definition">Definition at line <a class="el" href="ISceneManager_8h_source.html#l00129">129</a> of file <a class="el" href="ISceneManager_8h_source.html">ISceneManager.h</a>.</p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a8e2e0cd3a27e85b4116855dd2f3365b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2e0cd3a27e85b4116855dd2f3365b8">&#9670;&nbsp;</a></span>addAnimatedMeshSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IAnimatedMeshSceneNode.html">IAnimatedMeshSceneNode</a>* irr::scene::ISceneManager::addAnimatedMeshSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IAnimatedMesh.html">IAnimatedMesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f,&#160;1.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alsoAddIfMeshPointerZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node for rendering an animated mesh model. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Pointer to the loaded animated mesh to be displayed. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td class="paramname">id</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td class="paramname">rotation</td><td>Initial rotation of the scene node. </td></tr>
    <tr><td class="paramname">scale</td><td>Initial scale of the scene node. </td></tr>
    <tr><td class="paramname">alsoAddIfMeshPointerZero</td><td>Add the scene node even if a 0 pointer is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a3568947148f5c965dec8d37c4a1a2c29">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a00266a58b97e827acd9e105806a99c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00266a58b97e827acd9e105806a99c3a">&#9670;&nbsp;</a></span>addBillboardSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IBillboardSceneNode.html">IBillboardSceneNode</a>* irr::scene::ISceneManager::addBillboardSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt; <a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>size</em> = <code><a class="el" href="classirr_1_1core_1_1dimension2d.html">core::dimension2d</a>&lt;&#160;<a class="el" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07">f32</a>&#160;&gt;(10.0f,&#160;10.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>colorTop</em> = <code>0xFFFFFFFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1SColor.html">video::SColor</a>&#160;</td>
          <td class="paramname"><em>colorBottom</em> = <code>0xFFFFFFFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a billboard scene node to the scene graph. </p>
<p>A billboard is like a 3d sprite: A 2d element, which always looks to the camera. It is usually used for things like explosions, fire, lensflares and things like that. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parent</td><td>Parent scene node of the billboard. Can be null. If the parent moves, the billboard will move too. </td></tr>
    <tr><td class="paramname">size</td><td>Size of the billboard. This size is 2 dimensional because a billboard only has width and height. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the billboard will be placed. </td></tr>
    <tr><td class="paramname">id</td><td>An id of the node. This id can be used to identify the node. </td></tr>
    <tr><td class="paramname">colorTop</td><td>The color of the vertices at the top of the billboard (default: white). </td></tr>
    <tr><td class="paramname">colorBottom</td><td>The color of the vertices at the bottom of the billboard (default: white). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the billboard if successful, otherwise NULL. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a5e531de79552c22849c7053a56630905">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="afc3733849319078d5d22d94f58c7d1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc3733849319078d5d22d94f58c7d1f2">&#9670;&nbsp;</a></span>addCameraSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a>* irr::scene::ISceneManager::addCameraSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>lookat</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;100)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>makeActive</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a camera scene node to the scene graph and sets it as active camera. </p>
<p>This camera does not react on user input. If you want to move or animate it, use <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2166eb0a92cc0e46c49266f41a68ed50" title="Sets the position of the node relative to its parent.">ISceneNode::setPosition()</a>, <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html#a7280b07fd7915c64350db5a132b4ba07" title="Sets the look at target of the camera.">ICameraSceneNode::setTarget()</a> etc methods. By default, a camera's look at position (set with setTarget()) and its scene node rotation (set with setRotation()) are independent. If you want to be able to control the direction that the camera looks by using setRotation() then call ICameraSceneNode::bindTargetAndRotation(true) on it. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the camera will be placed. </td></tr>
    <tr><td class="paramname">lookat</td><td>Position where the camera will look at. Also known as target. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent scene node of the camera. Can be null. If the parent moves, the camera will move too. </td></tr>
    <tr><td class="paramname">id</td><td>id of the camera. This id can be used to identify the camera. </td></tr>
    <tr><td class="paramname">makeActive</td><td>Flag whether this camera should become the active one. Make sure you always have one active camera. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to interface to camera if successful, otherwise 0. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#abf93f869cca301288ee868f33d937a2a">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="guiEngine_8cpp_source.html#l00340">GUIEngine::cloudInit()</a>.</p>

</div>
</div>
<a id="ad7aa119894aa960f428b7baefcedc58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7aa119894aa960f428b7baefcedc58a">&#9670;&nbsp;</a></span>addDummyTransformationSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IDummyTransformationSceneNode.html">IDummyTransformationSceneNode</a>* irr::scene::ISceneManager::addDummyTransformationSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a dummy transformation scene node to the scene graph. </p>
<p>This scene node does not render itself, and does not respond to set/getPosition, set/getRotation and set/getScale. Its just a simple scene node that takes a matrix as relative transformation, making it possible to insert any transformation anywhere into the scene graph. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the created scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#ac0bc76b9d6392e8e63894464513546d2">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a3811d3d2a092474e2c5613d550678187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3811d3d2a092474e2c5613d550678187">&#9670;&nbsp;</a></span>addEmptySceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::addEmptySceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an empty scene node to the scene graph. </p>
<p>Can be used for doing advanced transformations or structuring the scene graph. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the created scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#adfc577c7785a0bee82faecf7a4f3f9b0">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGUITTFont_8cpp_source.html#l01088">irr::gui::CGUITTFont::addTextSceneNode()</a>, and <a class="el" href="guiScene_8cpp_source.html#l00076">GUIScene::draw()</a>.</p>

</div>
</div>
<a id="a808972cc001db86c0576c38b3b3fbbf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808972cc001db86c0576c38b3b3fbbf7">&#9670;&nbsp;</a></span>addExternalMeshLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::addExternalMeshLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a> *&#160;</td>
          <td class="paramname"><em>externalLoader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds an external mesh loader for extending the engine with new file formats. </p>
<p>If you want the engine to be extended with file formats it currently is not able to load (e.g. .cob), just implement the <a class="el" href="classirr_1_1scene_1_1IMeshLoader.html" title="Class which is able to load an animated mesh from a file.">IMeshLoader</a> interface in your loading class and add it with this method. Using this method it is also possible to override built-in mesh loaders with newer or updated versions without the need to recompile the engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">externalLoader</td><td>Implementation of a new mesh loader. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#abaa8f4ccdc293e29b2c43ad8d731dabb">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="aa0a32f9f5b13d94e24eed80bdb999919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a32f9f5b13d94e24eed80bdb999919">&#9670;&nbsp;</a></span>addMeshSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshSceneNode.html">IMeshSceneNode</a>* irr::scene::ISceneManager::addMeshSceneNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1IMesh.html">IMesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td>
          <td class="paramname"><em>id</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>position</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a> &amp;&#160;</td>
          <td class="paramname"><em>scale</em> = <code><a class="el" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811">core::vector3df</a>(1.0f,&#160;1.0f,&#160;1.0f)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alsoAddIfMeshPointerZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node for rendering a static mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>Pointer to the loaded static mesh to be displayed. </td></tr>
    <tr><td class="paramname">parent</td><td>Parent of the scene node. Can be NULL if no parent. </td></tr>
    <tr><td class="paramname">id</td><td>Id of the node. This id can be used to identify the scene node. </td></tr>
    <tr><td class="paramname">position</td><td>Position of the space relative to its parent where the scene node will be placed. </td></tr>
    <tr><td class="paramname">rotation</td><td>Initial rotation of the scene node. </td></tr>
    <tr><td class="paramname">scale</td><td>Initial scale of the scene node. </td></tr>
    <tr><td class="paramname">alsoAddIfMeshPointerZero</td><td>Add the scene node even if a 0 pointer is passed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#af49f0d0a13cd8730d3e39959412d0d1b">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGUITTFont_8cpp_source.html#l01088">irr::gui::CGUITTFont::addTextSceneNode()</a>.</p>

</div>
</div>
<a id="a11eac917a4c75c7a7730198d7bf31f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11eac917a4c75c7a7730198d7bf31f5a">&#9670;&nbsp;</a></span>addToDeletionQueue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::addToDeletionQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a scene node to the deletion queue. </p>
<p>The scene node is immediately deleted when it's secure. Which means when the scene node does not execute animators and things like that. This method is for example used for deleting scene nodes by their scene node animators. In most other cases, a <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#a2efa2670e29d6bb33b0dd99403b8b69c" title="Removes this scene node from the scene.">ISceneNode::remove()</a> call is enough, using this deletion queue is not necessary. See ISceneManager::createDeleteAnimator() for details. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a> to delete. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a97fc3727b04a2584f671f5f90a884c05">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="abaa3d11a833b89f7579848e234881988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa3d11a833b89f7579848e234881988">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the whole scene. </p>
<p>All scene nodes are removed. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#ada8251fdbeb8478b3985b729b65322c0">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="ad8e70b4a3a205f21d895a7d8deabae34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e70b4a3a205f21d895a7d8deabae34">&#9670;&nbsp;</a></span>clearAllRegisteredNodesForRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::clearAllRegisteredNodesForRendering </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear all nodes which are currently registered for rendering. </p>
<p>Usually you don't have to care about this as drawAll will clear nodes after rendering them. But sometimes you might have to manully reset this. For example when you deleted nodes between registering and rendering. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a50b83e72b7062fbb29470da4b28b3d4a">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="ae9a06fb68757381f99cfe11ecbd153e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a06fb68757381f99cfe11ecbd153e6">&#9670;&nbsp;</a></span>createMeshWriter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshWriter.html">IMeshWriter</a>* irr::scene::ISceneManager::createMeshWriter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a431fa15741518ba15f6d5f2608b6cb4e">EMESH_WRITER_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mesh writer implementation if available. </p>
<p>Note: You need to <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">drop()</a> the pointer after use again, see <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for details. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a0144a41062d045619c75fc5c3532b4b8">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a94805dd4eca41ccef9607aefe669aed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94805dd4eca41ccef9607aefe669aed9">&#9670;&nbsp;</a></span>createNewSceneManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a>* irr::scene::ISceneManager::createNewSceneManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>cloneContent</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a new scene manager. </p>
<p>This can be used to easily draw and/or store two independent scenes at the same time. The mesh cache will be shared between all existing scene managers, which means if you load a mesh in the original scene manager using for example <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#af0ff82d7bac969d6a30f67c7b1fa0c46" title="Get pointer to an animateable mesh. Loads the file if not loaded already.">getMesh()</a>, the mesh will be available in all other scene managers too, without loading. The original/main scene manager will still be there and accessible via <a class="el" href="classirr_1_1IrrlichtDevice.html#a891b503ff4d5041296d88f23f97d7b3d" title="Provides access to the scene manager.">IrrlichtDevice::getSceneManager()</a>. If you need input event in this new scene manager, for example for FPS cameras, you'll need to forward input to this manually: Just implement an <a class="el" href="classirr_1_1IEventReceiver.html" title="Interface of an object which can receive events.">IEventReceiver</a> and call yourNewSceneManager-&gt;<a class="el" href="classirr_1_1scene_1_1ISceneManager.html#ac68aa8d654884f19ad52fa28f11db424" title="Posts an input event to the environment.">postEventFromUser()</a>, and return true so that the original scene manager doesn't get the event. Otherwise, all input will go to the main scene manager automatically. If you no longer need the new scene manager, you should call <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">ISceneManager::drop()</a>. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a6e3fff9b2c18230a8df8fd8e7417f909">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a67015b46ffde252ba723e6dcc6a93ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67015b46ffde252ba723e6dcc6a93ac2">&#9670;&nbsp;</a></span>createSkinnedMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISkinnedMesh.html">ISkinnedMesh</a>* irr::scene::ISceneManager::createSkinnedMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a skinned mesh, which is not available as header-only code. </p>
<p>Note: You need to <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">drop()</a> the pointer after use again, see <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for details. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#afb8d2382f16de129cd11bfa16d83799b">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a04240262904667c821bd9de5e5fd9b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04240262904667c821bd9de5e5fd9b02">&#9670;&nbsp;</a></span>drawAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::drawAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws all the scene nodes. </p>
<p>This can only be invoked between <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#ad8e8b44bcd5c9a9a844dd491ef409857" title="Applications must call this method before performing any rendering.">IVideoDriver::beginScene()</a> and <a class="el" href="classirr_1_1video_1_1IVideoDriver.html#a75f61a93c5fc9fdf161c044d27bc994e" title="Presents the rendered image to the screen.">IVideoDriver::endScene()</a>. Please note that the scene is not only drawn when calling this, but also animated by existing scene node animators, culling of scene nodes is done, etc. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a489358affa0fab8651d62e5f89100494">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="guiEngine_8cpp_source.html#l00354">GUIEngine::cloudPreProcess()</a>, <a class="el" href="guiScene_8cpp_source.html#l00076">GUIScene::draw()</a>, and <a class="el" href="plain_8cpp_source.html#l00031">Draw3D::run()</a>.</p>

</div>
</div>
<a id="a71391ee37dece0714d95c519f110010f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71391ee37dece0714d95c519f110010f">&#9670;&nbsp;</a></span>getActiveCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a>* irr::scene::ISceneManager::getActiveCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current active camera. </p>
<dl class="section return"><dt>Returns</dt><dd>The active camera is returned. Note that this can be NULL, if there was no camera created yet. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a87c4a45715bf0d9d291ce8bb5e18bc7e">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="guiScene_8cpp_source.html#l00076">GUIScene::draw()</a>, <a class="el" href="CSceneCollisionManager_8cpp_source.html#l00039">irr::scene::CSceneCollisionManager::getRayFromScreenCoordinates()</a>, <a class="el" href="CCameraSceneNode_8cpp_source.html#l00232">irr::scene::CCameraSceneNode::OnRegisterSceneNode()</a>, <a class="el" href="CBillboardSceneNode_8cpp_source.html#l00068">irr::scene::CBillboardSceneNode::render()</a>, and <a class="el" href="sky_8cpp_source.html#l00113">Sky::render()</a>.</p>

</div>
</div>
<a id="af0ff82d7bac969d6a30f67c7b1fa0c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ff82d7bac969d6a30f67c7b1fa0c46">&#9670;&nbsp;</a></span>getMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IAnimatedMesh.html">IAnimatedMesh</a>* irr::scene::ISceneManager::getMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1IReadFile.html">io::IReadFile</a> *&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to an animateable mesh. Loads the file if not loaded already. </p>
<p>If you want to remove a loaded mesh from the cache again, use removeMesh(). Currently there are the following mesh formats supported: </p><table border="1" cellpadding="2" cellspacing="0">
<tr>
<td>Format </td><td>Description  </td></tr>
<tr>
<td>3D Studio (.3ds) </td><td>Loader for 3D-Studio files which lots of 3D packages are able to export. Only static meshes are currently supported by this importer.  </td></tr>
<tr>
<td>3D World Studio (.smf) </td><td>Loader for Leadwerks SMF mesh files, a simple mesh format containing static geometry for games. The proprietary .STF texture format is not supported yet. This loader was originally written by Joseph Ellis.   </td></tr>
<tr>
<td>Bliz Basic B3D (.b3d) </td><td>Loader for blitz basic files, developed by Mark Sibly. This is the ideal animated mesh format for game characters as it is both rigidly defined and widely supported by modeling and animation software. As this format supports skeletal animations, an <a class="el" href="classirr_1_1scene_1_1ISkinnedMesh.html" title="Interface for using some special functions of Skinned meshes.">ISkinnedMesh</a> will be returned by this importer.  </td></tr>
<tr>
<td>Cartography shop 4 (.csm) </td><td>Cartography Shop is a modeling program for creating architecture and calculating lighting. Irrlicht can directly import .csm files thanks to the IrrCSM library created by Saurav Mohapatra which is now integrated directly in Irrlicht.  </td></tr>
<tr>
<td>Delgine DeleD (.dmf) </td><td>DeleD (delgine.com) is a 3D editor and level-editor combined into one and is specifically designed for 3D game-development. With this loader, it is possible to directly load all geometry is as well as textures and lightmaps from .dmf files. To set texture and material paths, see scene::DMF_USE_MATERIALS_DIRS. It is also possible to flip the alpha texture by setting scene::DMF_FLIP_ALPHA_TEXTURES to true and to set the material transparent reference value by setting scene::DMF_ALPHA_CHANNEL_REF to a float between 0 and<ol type="1">
<li>The loader is based on Salvatore Russo's .dmf loader, I just changed some parts of it. Thanks to Salvatore for his work and for allowing me to use his code in Irrlicht and put it under Irrlicht's license. For newer and more enhanced versions of the loader, take a look at delgine.com.   </li>
</ol>
</td></tr>
<tr>
<td>DirectX (.x) </td><td>Platform independent importer (so not D3D-only) for .x files. Most 3D packages can export these natively and there are several tools for them available, e.g. the Maya exporter included in the DX SDK. .x files can include skeletal animations and Irrlicht is able to play and display them, users can manipulate the joints via the <a class="el" href="classirr_1_1scene_1_1ISkinnedMesh.html" title="Interface for using some special functions of Skinned meshes.">ISkinnedMesh</a> interface. Currently, Irrlicht only supports uncompressed .x files.  </td></tr>
<tr>
<td>Half-Life model (.mdl) </td><td>This loader opens Half-life 1 models, it was contributed by Fabio Concas and adapted by Thomas Alten.  </td></tr>
<tr>
<td>LightWave (.lwo) </td><td>Native to NewTek's LightWave 3D, the LWO format is well known and supported by many exporters. This loader will import LWO2 models including lightmaps, bumpmaps and reflection textures.  </td></tr>
<tr>
<td>Maya (.obj) </td><td>Most 3D software can create .obj files which contain static geometry without material data. The material files .mtl are also supported. This importer for Irrlicht can load them directly.   </td></tr>
<tr>
<td>Milkshape (.ms3d) </td><td>.MS3D files contain models and sometimes skeletal animations from the Milkshape 3D modeling and animation software. Like the other skeletal mesh loaders, joints are exposed via the <a class="el" href="classirr_1_1scene_1_1ISkinnedMesh.html" title="Interface for using some special functions of Skinned meshes.">ISkinnedMesh</a> animated mesh type.  </td></tr>
<tr>
<td>My3D (.my3d) </td><td>.my3D is a flexible 3D file format. The My3DTools contains plug-ins to export .my3D files from several 3D packages. With this built-in importer, Irrlicht can read and display those files directly. This loader was written by Zhuck Dimitry who also created the whole My3DTools package.   </td></tr>
<tr>
<td>OCT (.oct) </td><td>The oct file format contains 3D geometry and lightmaps and can be loaded directly by Irrlicht. OCT files<br  />
 can be created by FSRad, Paul Nette's radiosity processor or exported from Blender using OCTTools which can be found in the exporters/OCTTools directory of the SDK. Thanks to Murphy McCauley for creating all this.  </td></tr>
<tr>
<td>OGRE Meshes (.mesh) </td><td>Ogre .mesh files contain 3D data for the OGRE 3D engine. Irrlicht can read and display them directly with this importer. To define materials for the mesh, copy a .material file named like the corresponding .mesh file where the .mesh file is. (For example ogrehead.material for ogrehead.mesh). Thanks to Christian Stehno who wrote and contributed this loader.  </td></tr>
<tr>
<td>Pulsar LMTools (.lmts) </td><td>LMTools is a set of tools (Windows &amp; Linux) for creating lightmaps. Irrlicht can directly read .lmts files thanks to<br  />
 the importer created by Jonas Petersen. Notes for<br  />
 this version of the loader:<br  />
<ul>
<li>It does not recognize/support user data in the *.lmts files.<br  />
</li>
<li>The TGAs generated by LMTools don't work in Irrlicht for some reason (the textures are upside down). Opening and resaving them in a graphics app will solve the problem.  </li>
</ul>
</td></tr>
<tr>
<td>Quake 3 levels (.bsp) </td><td>Quake 3 is a popular game by IDSoftware, and .pk3 files contain .bsp files and textures/lightmaps describing huge prelighted levels. Irrlicht can read .pk3 and .bsp files directly and thus render Quake 3 levels directly. Written by Nikolaus Gebhardt enhanced by Dean P. Macri with the curved surfaces feature.   </td></tr>
<tr>
<td>Quake 2 models (.md2) </td><td>Quake 2 models are characters with morph target animation. Irrlicht can read, display and animate them directly with this importer.   </td></tr>
<tr>
<td>Quake 3 models (.md3) </td><td>Quake 3 models are characters with morph target animation, they contain mount points for weapons and body parts and are typically made of several sections which are manually joined together.  </td></tr>
<tr>
<td>Stanford Triangle (.ply) </td><td>Invented by Stanford University and known as the native format of the infamous "Stanford Bunny" model, this is a popular static mesh format used by 3D scanning hardware and software. This loader supports extremely large models in both ASCII and binary format, but only has rudimentary material support in the form of vertex colors and texture coordinates.  </td></tr>
<tr>
<td>Stereolithography (.stl) </td><td>The STL format is used for rapid prototyping and computer-aided manufacturing, thus has no support for materials.  </td></tr>
</table>
<p>To load and display a mesh quickly, just do this: </p><div class="fragment"><div class="line">SceneManager-&gt;addAnimatedMeshSceneNode(</div>
<div class="line">   SceneManager-&gt;getMesh(<span class="stringliteral">&quot;yourmesh.3ds&quot;</span>));</div>
</div><!-- fragment --><p> If you would like to implement and add your own file format loader to Irrlicht, see <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#a808972cc001db86c0576c38b3b3fbbf7" title="Adds an external mesh loader for extending the engine with new file formats.">addExternalMeshLoader()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>File handle of the mesh to load. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Null if failed, otherwise pointer to the mesh. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#af75cb7c567444c6102da17d8df7668db">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a45d89c816e33abe0e77eb063d7ce58a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d89c816e33abe0e77eb063d7ce58a8">&#9670;&nbsp;</a></span>getMeshCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshCache.html">IMeshCache</a>* irr::scene::ISceneManager::getMeshCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interface to the mesh cache which is shared between all existing scene managers. </p>
<p>With this interface, it is possible to manually add new loaded meshes (if <a class="el" href="classirr_1_1scene_1_1ISceneManager.html#af0ff82d7bac969d6a30f67c7b1fa0c46" title="Get pointer to an animateable mesh. Loads the file if not loaded already.">ISceneManager::getMesh()</a> is not sufficient), to remove them and to iterate through already loaded meshes. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#abf87d9f7f220b7c244f1be2598a57cc9">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="afabf244b50875a52eb42d5d375fa40d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabf244b50875a52eb42d5d375fa40d4">&#9670;&nbsp;</a></span>getMeshLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshLoader.html">IMeshLoader</a>* irr::scene::ISceneManager::getMeshLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a4fa562acf3a986421a3aa7e966b07d69">u32</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieve the given mesh loader. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the loader to retrieve. This parameter is an 0-based array index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the specified loader, 0 if the index is incorrect. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a3d313110df1de01ad55516ae1887f350">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a05138d6b5f99fced0061794fb5c42318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05138d6b5f99fced0061794fb5c42318">&#9670;&nbsp;</a></span>getMeshManipulator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1IMeshManipulator.html">IMeshManipulator</a>* irr::scene::ISceneManager::getMeshManipulator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the mesh manipulator. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the mesh manipulator This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a1c61b04de27d57b420e5cfd7457d7235">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGUITTFont_8cpp_source.html#l01088">irr::gui::CGUITTFont::addTextSceneNode()</a>, and <a class="el" href="COBJMeshFileLoader_8cpp_source.html#l00054">irr::scene::COBJMeshFileLoader::createMesh()</a>.</p>

</div>
</div>
<a id="a4dba8ee7f48fdf6ede2c3f4b5fabcad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dba8ee7f48fdf6ede2c3f4b5fabcad3">&#9670;&nbsp;</a></span>getParameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1io_1_1IAttributes.html">io::IAttributes</a>* irr::scene::ISceneManager::getParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get interface to the parameters set in this scene. </p>
<p>String parameters can be used by plugins and mesh loaders. See COLLADA_CREATE_SCENE_INSTANCES and DMF_USE_MATERIALS_DIRS </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a5bcdc3db55fba70c9fcc985b688cb261">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="COBJMeshFileLoader_8cpp_source.html#l00054">irr::scene::COBJMeshFileLoader::createMesh()</a>.</p>

</div>
</div>
<a id="a4f7075320f1a3bf2838f29c23f78635f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7075320f1a3bf2838f29c23f78635f">&#9670;&nbsp;</a></span>getRootSceneNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::getRootSceneNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the root scene node. </p>
<p>This is the scene node which is parent of all scene nodes. The root scene node is a special scene node which only exists to manage all scene nodes. It will not be rendered and cannot be removed from the scene. </p><dl class="section return"><dt>Returns</dt><dd>Pointer to the root scene node. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a92da3184e0857e35531f9f51c94053a4">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CGUITTFont_8cpp_source.html#l01088">irr::gui::CGUITTFont::addTextSceneNode()</a>, and <a class="el" href="plain_8cpp_source.html#l00088">RenderShadowMapStep::run()</a>.</p>

</div>
</div>
<a id="a433b65bfc974d069a1dc2fc296b23d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a433b65bfc974d069a1dc2fc296b23d9b">&#9670;&nbsp;</a></span>getSceneCollisionManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneCollisionManager.html">ISceneCollisionManager</a>* irr::scene::ISceneManager::getSceneCollisionManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to the scene collision manager. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the collision manager This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a26b4951de937a08185b13ca031d98fcb">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a038e2afb1397fe8f2b6f8f6c55d52b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038e2afb1397fe8f2b6f8f6c55d52b55">&#9670;&nbsp;</a></span>getSceneNodeFromId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::getSceneNodeFromId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#aa4d51f89adbce4bfc7e743a39ee895cd">s32</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first scene node with the specified id. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>The id to search for </td></tr>
    <tr><td class="paramname">start</td><td>Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first scene node with this id, and null if no scene node could be found. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a5483ea725f868e3efdac749163b3f579">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a13ada3cca4b9eadee5e8ba3ccb6683da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ada3cca4b9eadee5e8ba3ccb6683da">&#9670;&nbsp;</a></span>getSceneNodeFromName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::getSceneNodeFromName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first scene node with the specified name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to search for </td></tr>
    <tr><td class="paramname">start</td><td>Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first scene node with this id, and null if no scene node could be found. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a643cf45fd3889edd7c2f66f2f17556d0">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a5ab8e8f8cc8456a3ea881c75dfe505bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab8e8f8cc8456a3ea881c75dfe505bb">&#9670;&nbsp;</a></span>getSceneNodeFromType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a>* irr::scene::ISceneManager::getSceneNodeFromType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">scene::ESCENE_NODE_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the first scene node with the specified type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type to search for </td></tr>
    <tr><td class="paramname">start</td><td>Scene node to start from. All children of this scene node are searched. If null is specified, the root scene node is taken. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the first scene node with this type, and null if no scene node could be found. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#ac15ab886c74a0a4324e284ad1b8aaa73">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="a2b8f844a1367d80648bc055a5639807b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b8f844a1367d80648bc055a5639807b">&#9670;&nbsp;</a></span>getSceneNodeRenderPass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a> irr::scene::ISceneManager::getSceneNodeRenderPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get current render pass. </p>
<p>All scene nodes are being rendered in a specific order. First lights, cameras, sky boxes, solid geometry, and then transparent stuff. During the rendering process, scene nodes may want to know what the scene manager is rendering currently, because for example they registered for rendering twice, once for transparent geometry and once for solid. When knowing what rendering pass currently is active they can render the correct part of their geometry. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a00b92fa9e8e9a124afd1175c8474fdf1">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CMeshSceneNode_8cpp_source.html#l00090">irr::scene::CMeshSceneNode::render()</a>, <a class="el" href="CAnimatedMeshSceneNode_8cpp_source.html#l00248">irr::scene::CAnimatedMeshSceneNode::render()</a>, <a class="el" href="clouds_8cpp_source.html#l00090">Clouds::render()</a>, and <a class="el" href="clientmap_8h_source.html#l00104">ClientMap::render()</a>.</p>

</div>
</div>
<a id="a9afcad318b725b5f95e19c839145d3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afcad318b725b5f95e19c839145d3d6">&#9670;&nbsp;</a></span>getSceneNodesFromType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::getSceneNodesFromType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#acad3d7ef92a9807d391ba29120f3b7bd">ESCENE_NODE_TYPE</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1core_1_1array.html">core::array</a>&lt; <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">scene::ISceneNode</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>outNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>start</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get scene nodes by type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Type of scene node to find (ESNT_ANY will return all child nodes). </td></tr>
    <tr><td class="paramname">outNodes</td><td>results will be added to this array (outNodes is not cleared). </td></tr>
    <tr><td class="paramname">start</td><td>Scene node to start from. This node and all children of this scene node are checked (recursively, so also children of children, etc). If null is specified, the root scene node is taken as start-node. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#aeb110eac0b799b7d93d99bc4e25fca71">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="afde082160205a8faab44cd5b61e3745c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde082160205a8faab44cd5b61e3745c">&#9670;&nbsp;</a></span>getVideoDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classirr_1_1video_1_1IVideoDriver.html">video::IVideoDriver</a>* irr::scene::ISceneManager::getVideoDriver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the video driver. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the video Driver. This pointer should not be dropped. See <a class="el" href="classirr_1_1IReferenceCounted.html#a03856a09355b89d178090c4a5f738543" title="Drops the object. Decrements the reference counter by one.">IReferenceCounted::drop()</a> for more information. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a7e5180e1b9fa95b5e9b67d3f73200263">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CCameraSceneNode_8cpp_source.html#l00017">irr::scene::CCameraSceneNode::CCameraSceneNode()</a>, <a class="el" href="CMeshSceneNode_8cpp_source.html#l00046">irr::scene::CMeshSceneNode::OnRegisterSceneNode()</a>, <a class="el" href="CAnimatedMeshSceneNode_8cpp_source.html#l00138">irr::scene::CAnimatedMeshSceneNode::OnRegisterSceneNode()</a>, <a class="el" href="CMeshSceneNode_8cpp_source.html#l00090">irr::scene::CMeshSceneNode::render()</a>, <a class="el" href="CBillboardSceneNode_8cpp_source.html#l00068">irr::scene::CBillboardSceneNode::render()</a>, <a class="el" href="CAnimatedMeshSceneNode_8cpp_source.html#l00248">irr::scene::CAnimatedMeshSceneNode::render()</a>, <a class="el" href="sky_8cpp_source.html#l00113">Sky::render()</a>, <a class="el" href="clouds_8cpp_source.html#l00090">Clouds::render()</a>, <a class="el" href="client_2particles_8cpp_source.html#l00162">Particle::render()</a>, <a class="el" href="clientmap_8h_source.html#l00104">ClientMap::render()</a>, and <a class="el" href="CCameraSceneNode_8cpp_source.html#l00242">irr::scene::CCameraSceneNode::render()</a>.</p>

</div>
</div>
<a id="aff6c6d553e0faf12bbfd33e814ad4352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff6c6d553e0faf12bbfd33e814ad4352">&#9670;&nbsp;</a></span>isCulled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> irr::scene::ISceneManager::isCulled </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if node is culled in current view frustum. </p>
<p>Please note that depending on the used culling method this check can be rather coarse, or slow. A positive result is correct, though, i.e. if this method returns true the node is positively not visible. The node might still be invisible even if this method returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The scene node which is checked for culling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if node is not visible in the current scene, else false. </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#af81eb891193799eeee0bad755d85996d">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<a id="ac68aa8d654884f19ad52fa28f11db424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68aa8d654884f19ad52fa28f11db424">&#9670;&nbsp;</a></span>postEventFromUser()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> irr::scene::ISceneManager::postEventFromUser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structirr_1_1SEvent.html">SEvent</a> &amp;&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Posts an input event to the environment. </p>
<p>Usually you do not have to use this method, it is used by the internal engine. </p>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a9286de86f71ac686c0615481fe6942b3">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CIrrDeviceStub_8cpp_source.html#l00216">irr::CIrrDeviceStub::postEventFromUser()</a>.</p>

</div>
</div>
<a id="aaf17bdde6d4e9ef61a76f3b43100ecb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf17bdde6d4e9ef61a76f3b43100ecb8">&#9670;&nbsp;</a></span>registerNodeForRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#a4fa562acf3a986421a3aa7e966b07d69">u32</a> irr::scene::ISceneManager::registerNodeForRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ISceneNode.html">ISceneNode</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f">E_SCENE_NODE_RENDER_PASS</a>&#160;</td>
          <td class="paramname"><em>pass</em> = <code><a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67fa5ceee6e4bc2fab42c663b32018e276e8">ESNRP_AUTOMATIC</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a node for rendering it at a specific time. </p>
<p>This method should only be used by SceneNodes when they get a <a class="el" href="classirr_1_1scene_1_1ISceneNode.html#ac9795bfcb88dcaf8cba6ea3296e5d8d0" title="This method is called just before the rendering process of the whole scene.">ISceneNode::OnRegisterSceneNode()</a> call. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structNode.html">Node</a> to register for drawing. Usually scene nodes would set 'this' as parameter here because they want to be drawn. </td></tr>
    <tr><td class="paramname">pass</td><td>Specifies when the node wants to be drawn in relation to the other nodes. For example, if the node is a shadow, it usually wants to be drawn after all other nodes and will use ESNRP_SHADOW for this. See <a class="el" href="namespaceirr_1_1scene.html#a7862269bd1abc123929d4dbb8200d67f" title="Enumeration for render passes.">scene::E_SCENE_NODE_RENDER_PASS</a> for details. Note: This is <em>not</em> a bitfield. If you want to register a note for several render passes, then call this function once for each pass. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scene will be rendered ( passed culling ) </dd></dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#a5e2ec8770bbbff9a604a92d689bdf4ff">irr::scene::CSceneManager</a>.</p>

<p class="reference">Referenced by <a class="el" href="CEmptySceneNode_8cpp_source.html#l00026">irr::scene::CEmptySceneNode::OnRegisterSceneNode()</a>, <a class="el" href="CMeshSceneNode_8cpp_source.html#l00046">irr::scene::CMeshSceneNode::OnRegisterSceneNode()</a>, <a class="el" href="CBillboardSceneNode_8cpp_source.html#l00058">irr::scene::CBillboardSceneNode::OnRegisterSceneNode()</a>, <a class="el" href="CAnimatedMeshSceneNode_8cpp_source.html#l00138">irr::scene::CAnimatedMeshSceneNode::OnRegisterSceneNode()</a>, <a class="el" href="sky_8cpp_source.html#l00105">Sky::OnRegisterSceneNode()</a>, <a class="el" href="clouds_8cpp_source.html#l00079">Clouds::OnRegisterSceneNode()</a>, <a class="el" href="client_2particles_8cpp_source.html#l00154">Particle::OnRegisterSceneNode()</a>, <a class="el" href="clientmap_8cpp_source.html#l00163">ClientMap::OnRegisterSceneNode()</a>, and <a class="el" href="CCameraSceneNode_8cpp_source.html#l00232">irr::scene::CCameraSceneNode::OnRegisterSceneNode()</a>.</p>

</div>
</div>
<a id="a5d19b7a6803a0a021082fc2b86043b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d19b7a6803a0a021082fc2b86043b3d">&#9670;&nbsp;</a></span>setActiveCamera()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::ISceneManager::setActiveCamera </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1scene_1_1ICameraSceneNode.html">ICameraSceneNode</a> *&#160;</td>
          <td class="paramname"><em>camera</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the currently active camera. </p>
<p>The previous active camera will be deactivated. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">camera</td><td>The new camera which should be active. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classirr_1_1scene_1_1CSceneManager.html#ab51eada7234e5e5b3a2cd504126d7817">irr::scene::CSceneManager</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>lib/irrlichtmt/include/<a class="el" href="ISceneManager_8h_source.html">ISceneManager.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceirr.html">irr</a></li><li class="navelem"><a class="el" href="namespaceirr_1_1scene.html">scene</a></li><li class="navelem"><a class="el" href="classirr_1_1scene_1_1ISceneManager.html">ISceneManager</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
